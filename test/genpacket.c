
#ifndef GENPACKET_CQC_H
#define GENPACKET_CQC_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define static_assert(pred, msg) _Static_assert( (pred), msg);

struct cqc {
    int head;
    int tail;
    int size;
};


#ifdef CQC_USE_MODULO

    /* Init Circular buffer. In the case of Module, given size is the size of the buffer. */
#define cqc_init(cqc, sz) do { (cqc).size = sz; (cqc).tail = 0; (cqc).head = 0; } while (0)
    /* Size given with init. */
#define cqc_qsz(cqc)        ( (cqc).size )
    /* Number of Items in the buffer. */
#define cqc_cnt(cqc)        ( ((cqc).head-(cqc).tail) % ((cqc).size) )
    /* Add new item, returns a free index and updates bookkeeping. */
#define cqc_put(cqc)        ( ((cqc).head++)          % ((cqc).size) )
    /* Retreive item, returns an used index and updates bookkeeping. */
#define cqc_get(cqc)        ( ((cqc).tail++)          % ((cqc).size) )
    /* Retreive item idx, does not touch bookkeeping. */
#define cqc_peek(cqc, idx)  ( ((cqc).tail+idx)        % ((cqc).size) )
    /* Space left in the buffer. */
#define cqc_space(cqc)      ( ((cqc).size)            - (cqc_cnt(cqc)) )

#define cqc_cnt_to_end(cqc)     ({int end = (cqc.size) - (cqc.tail); int n = ((cqc.head) + end) & ((cqc.size)-1); n < end ? n : end;})
#define cqc_space_to_end(cqc)   ({int end = (cqc.size) - 1 - (cqc.head); int n = (end + (cqc.tail)) & ((cqc.size)-1); n <= end ? n : end+1;})

#elif !defined(CQC_USE_MODULO)

    /* Init Circular buffer. In the case of AND, given size is the nearest power of 2 of the given size. cqc_qsz should be used to initialise the buffer. */
#define cqc_init(cqc, sz) do { static_assert(sz != 0, "cqc sz is zero"); static_assert( (sz & (sz-1) ) == 0, "cqc sz is not a power of 2."); (cqc).size = sz-1; (cqc).tail = 0; (cqc).head = 0; } while (0)
    /* Size calculated in init. */
#define cqc_qsz(cqc)        ( (cqc).size+1 )
    /* Number of Items in the buffer. */
#define cqc_cnt(cqc)        ( ((cqc).head-(cqc).tail) & ((cqc).size) )
    /* Retreive item, returns an used index and updates bookkeeping. */
#define cqc_put(cqc)        ( ((cqc).head++)          & ((cqc).size) )
    /* Retreive item, returns an used index and updates bookkeeping. */
#define cqc_get(cqc)        ( ((cqc).tail++)          & ((cqc).size) )
    /* Retreive item idx, does not touch bookkeeping. */
#define cqc_peek(cqc, idx)  ( ((cqc).tail+idx)        & ((cqc).size) )
    /* Space left in the buffer. */
#define cqc_space(cqc)      ( ((cqc).size)            - (cqc_cnt(cqc)) )

#define cqc_cnt_to_end(cqc)     ({int end = (cqc.size) - (cqc.tail); int n = ((cqc.head) + end) & ((cqc.size)-1); n < end ? n : end;})
#define cqc_space_to_end(cqc)   ({int end = (cqc.size) - 1 - (cqc.head); int n = (end + (cqc.tail)) & ((cqc.size)-1); n <= end ? n : end+1;})

#endif /* CQC_USE_MODULO */

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* GENPACKET_CQC_H */

/*
  File autogenerated by TBD 1
  generated with the following command:
  TBD TBD

  The developers of genpacket consider the fixed text that goes in all
  genpacket output files to be in the public domain:
  we make no copyright claims on it.
*/
 
/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h> 
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <poll.h>


#include "genpacket.h"

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#define ARRAY_SZ(a) (sizeof(a) / sizeof(a[0]))
#define GENPACKET_READ_SZ (8)

struct genpacket_ctx {
    struct genpacket_params params;

    /* TODO: One receive queue per pipe */
    uint8_t recv_buff[64];
    struct cqc recv_buff_cqc;

    struct pollfd pfds[GENPACKET_NRO_PIPES * 2];
};

static struct genpacket_ctx genpacket_ctx;

static bool test_p0_fixed(struct genpacket_ctx *ctx, int head) {
    int cnt = cqc_cnt(ctx->recv_buff_cqc);
    if (cnt < 31) return -1;

    int retval = 31;
    struct p0_fixed *packet = (struct p0_fixed *) &ctx->recv_buff[head];
    
    if (packet->frame0 != 0x10) return -1;
    if (packet->frame1 != 0x30) return -1;
    if (packet->frame2 != 0x20) return -1;


    return retval;
}
static bool test_p1_fixed(struct genpacket_ctx *ctx, int head) {
    int cnt = cqc_cnt(ctx->recv_buff_cqc);
    if (cnt < 12) return -1;
    return 12;
}
static bool test_p2_fixed(struct genpacket_ctx *ctx, int head) {
    int cnt = cqc_cnt(ctx->recv_buff_cqc);
    if (cnt < 46) return -1;

    int retval = 46;
    struct p2_fixed *packet = (struct p2_fixed *) &ctx->recv_buff[head];
    
    if (packet->frame0 != 0x10) return -1;


    return retval;
}
static int test_p3_calculated(struct genpacket_ctx *ctx, int head) {
    int cnt = cqc_cnt(ctx->recv_buff_cqc);
    if (cnt < 7) return -1;

    int retval = 7;
    struct p3_calculated *packet = (struct p3_calculated *) &ctx->recv_buff[head];
    return -1;

    return retval;
}
int genpacket_p0_fixed_send(struct p0_fixed *packet) {
write(genpacket_ctx.params.wfds[0], &packet->frame0, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute0, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute1, 2);
    write(genpacket_ctx.params.wfds[0], &packet->attribute2, 4);
    write(genpacket_ctx.params.wfds[0], &packet->data0, 4);
    write(genpacket_ctx.params.wfds[0], &packet->data1, 2);
    write(genpacket_ctx.params.wfds[0], &packet->data2, 4);
    write(genpacket_ctx.params.wfds[0], &packet->data3, 3);
    write(genpacket_ctx.params.wfds[0], &packet->data4, 3);
    write(genpacket_ctx.params.wfds[0], &packet->frame1, 1);
    write(genpacket_ctx.params.wfds[0], &packet->data5, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute3, 1);
    write(genpacket_ctx.params.wfds[0], &packet->data6, 2);
    write(genpacket_ctx.params.wfds[0], &packet->crc0, 1);
    write(genpacket_ctx.params.wfds[0], &packet->frame2, 1);
    }
int genpacket_p1_fixed_send(struct p1_fixed *packet) {
write(genpacket_ctx.params.wfds[0], &packet->attribute0, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute1, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute2, 1);
    write(genpacket_ctx.params.wfds[0], &packet->data0, 4);
    write(genpacket_ctx.params.wfds[0], &packet->attribute3, 1);
    write(genpacket_ctx.params.wfds[0], &packet->crc0, 4);
    }
int genpacket_p2_fixed_send(struct p2_fixed *packet) {
write(genpacket_ctx.params.wfds[0], &packet->frame0, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute0, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute1, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute2, 1);
    write(genpacket_ctx.params.wfds[0], &packet->data0, 40);
    write(genpacket_ctx.params.wfds[0], &packet->crc0, 2);
    }
int genpacket_p3_calculated_send(struct p3_calculated *packet) {
write(genpacket_ctx.params.wfds[0], &packet->frame0, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute0, 1);
    write(genpacket_ctx.params.wfds[0], &packet->sz2, 1);
    write(genpacket_ctx.params.wfds[0], &packet->sz, 1);
    write(genpacket_ctx.params.wfds[0], &packet->attribute1, 1);
    write(genpacket_ctx.params.wfds[0], &packet->data0, 0);
    write(genpacket_ctx.params.wfds[0], &packet->attribute2, 1);
    write(genpacket_ctx.params.wfds[0], &packet->data1, 0);
    write(genpacket_ctx.params.wfds[0], &packet->crc0, 1);
    }

static bool check_fds(struct genpacket_ctx *ctx, int timeout) {

    if (poll(ctx->pfds, GENPACKET_NRO_PIPES *2, timeout) > 0) return true;
    return false;
}

static bool check_read_fds(struct genpacket_ctx *ctx, int pipe) {
    for (int i = 0; i < (GENPACKET_NRO_PIPES *2); i++) {
        /* TODO: check for specific pipe here! */
        if ( (ctx->pfds[i].revents & POLLIN) > 0) return true;
    }

    return false;
}

static bool check_write_fds(struct genpacket_ctx *ctx, int pipe) {
    for (int i = 0; i < (GENPACKET_NRO_PIPES *2); i++) {
        /* TODO: check for specific pipe here! */
        if ( (ctx->pfds[i].revents & POLLOUT) > 0) return true;
    }

    return false;
}

int genpacket_init(struct genpacket_params *params) {
    memcpy(&genpacket_ctx.params, params, sizeof(struct genpacket_params) );

    cqc_init(genpacket_ctx.recv_buff_cqc,ARRAY_SZ(genpacket_ctx.recv_buff));
    memset(&genpacket_ctx.recv_buff, 0x0, cqc_qsz(genpacket_ctx.recv_buff_cqc) );

    int fd = 0;
    for (int i = 0; i < GENPACKET_NRO_PIPES; i++) {
        genpacket_ctx.pfds[fd].fd = genpacket_ctx.params.rfds[i];
        genpacket_ctx.pfds[fd].events = POLLIN;

        if (genpacket_ctx.params.rfds[i] == genpacket_ctx.params.wfds[i]) {
            genpacket_ctx.pfds[fd].events |= POLLOUT;
        }
        else {
            fd++;
            genpacket_ctx.pfds[fd].fd = genpacket_ctx.params.wfds[i];
            genpacket_ctx.pfds[fd].events = POLLOUT;
        }
    }

    return (EXIT_SUCCESS);
}

int genpacket_process(int timeout) {
    if (check_fds(&genpacket_ctx, timeout) ) {
        /* TODO: check_read per pipe */
        if (check_read_fds(&genpacket_ctx, 0) ) {
            if (cqc_space(genpacket_ctx.recv_buff_cqc) > 0) {
                int readsz = cqc_space_to_end(genpacket_ctx.recv_buff_cqc);
                int head = genpacket_ctx.recv_buff_cqc.head;
                int rdsz_r = read(genpacket_ctx.params.rfds[0], &genpacket_ctx.recv_buff[head], readsz);
                genpacket_ctx.recv_buff_cqc.head += rdsz_r;
            }

            /* 
               These test functions return '-1' when their packet is not (completely) found. 
               Else they will return the size of the packet.
            */
            
            while (cqc_space(genpacket_ctx.recv_buff_cqc) < GENPACKET_READ_SZ) {
                int head = cqc_peek(genpacket_ctx.recv_buff_cqc, 0);
                int size = -1;

                
                if ( (size == -1) && (size = (test_p0_fixed(&genpacket_ctx, head) ) ) ) genpacket_p0_fixed_received( (struct p0_fixed *) &genpacket_ctx.recv_buff[head], genpacket_ctx.params.private_ctx);
                if ( (size == -1) && (size = (test_p1_fixed(&genpacket_ctx, head) ) ) ) genpacket_p1_fixed_received( (struct p1_fixed *) &genpacket_ctx.recv_buff[head], genpacket_ctx.params.private_ctx);
                if ( (size == -1) && (size = (test_p2_fixed(&genpacket_ctx, head) ) ) ) genpacket_p2_fixed_received( (struct p2_fixed *) &genpacket_ctx.recv_buff[head], genpacket_ctx.params.private_ctx);
                if ( (size == -1) && (size = (test_p3_calculated(&genpacket_ctx, head) ) ) ) genpacket_p3_calculated_received( (struct p3_calculated *) &genpacket_ctx.recv_buff[head], genpacket_ctx.params.private_ctx);


                if (size == -1) genpacket_ctx.recv_buff_cqc.tail--;
                else genpacket_ctx.recv_buff_cqc.tail -= size;
            }
        }
    }

    return (EXIT_SUCCESS);
}

