
#ifndef GENPACKET_CQC_H
#define GENPACKET_CQC_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define static_assert(pred, msg) _Static_assert( (pred), msg);

struct cqc {
    int head;
    int tail;
    int size;
};


#ifdef CQC_USE_MODULO

    /* Init Circular buffer. In the case of Module, given size is the size of the buffer. */
#define cqc_init(cqc, sz) do { (cqc).size = sz; (cqc).tail = 0; (cqc).head = 0; } while (0)
    /* Size given with init. */
#define cqc_qsz(cqc)        ( (cqc).size )
    /* Number of Items in the buffer. */
#define cqc_cnt(cqc)        ( ((cqc).head-(cqc).tail) % ((cqc).size) )
    /* Add new item, returns a free index and updates bookkeeping. */
#define cqc_put(cqc)        ( ((cqc).head++)          % ((cqc).size) )
    /* Retreive item, returns an used index and updates bookkeeping. */
#define cqc_get(cqc)        ( ((cqc).tail++)          % ((cqc).size) )
    /* Retreive item idx, does not touch bookkeeping. */
#define cqc_peek(cqc, idx)  ( ((cqc).tail+idx)        % ((cqc).size) )
    /* Space left in the buffer. */
#define cqc_space(cqc)      ( ((cqc).size)            - (cqc_cnt(cqc)) )

#define cqc_cnt_to_end(cqc)     ({int end = (cqc.size) - (cqc.tail); int n = ((cqc.head) + end) & ((cqc.size)-1); n < end ? n : end;})
#define cqc_space_to_end(cqc)   ({int end = (cqc.size) - 1 - (cqc.head); int n = (end + (cqc.tail)) & ((cqc.size)-1); n <= end ? n : end+1;})

#elif !defined(CQC_USE_MODULO)

    /* Init Circular buffer. In the case of AND, given size is the nearest power of 2 of the given size. cqc_qsz should be used to initialise the buffer. */
#define cqc_init(cqc, sz) do { static_assert(sz != 0, "cqc sz is zero"); static_assert( (sz & (sz-1) ) == 0, "cqc sz is not a power of 2."); (cqc).size = sz-1; (cqc).tail = 0; (cqc).head = 0; } while (0)
    /* Size calculated in init. */
#define cqc_qsz(cqc)        ( (cqc).size+1 )
    /* Number of Items in the buffer. */
#define cqc_cnt(cqc)        ( ((cqc).head-(cqc).tail) & ((cqc).size) )
    /* Retreive item, returns an used index and updates bookkeeping. */
#define cqc_put(cqc)        ( ((cqc).head++)          & ((cqc).size) )
    /* Retreive item, returns an used index and updates bookkeeping. */
#define cqc_get(cqc)        ( ((cqc).tail++)          & ((cqc).size) )
    /* Retreive item idx, does not touch bookkeeping. */
#define cqc_peek(cqc, idx)  ( ((cqc).tail+idx)        & ((cqc).size) )
    /* Space left in the buffer. */
#define cqc_space(cqc)      ( ((cqc).size)            - (cqc_cnt(cqc)) )

#define cqc_cnt_to_end(cqc)     ({int end = (cqc.size) - (cqc.tail); int n = ((cqc.head) + end) & ((cqc.size)-1); n < end ? n : end;})
#define cqc_space_to_end(cqc)   ({int end = (cqc.size) - 1 - (cqc.head); int n = (end + (cqc.tail)) & ((cqc.size)-1); n <= end ? n : end+1;})

#endif /* CQC_USE_MODULO */

#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* GENPACKET_CQC_H */

/*
  File autogenerated by TBD 1
  generated with the following command:
  TBD TBD

  The developers of genpacket consider the fixed text that goes in all
  genpacket output files to be in the public domain:
  we make no copyright claims on it.
*/
 
/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h> 
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <poll.h>

#include "genpacket.h"

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#define ARRAY_SZ(a) (sizeof(a) / sizeof(a[0]))
#define GENPACKET_READ_SZ (8)

struct genpacket_ctx {
    struct genpacket_params params;

    uint8_t recv_buff[64];
    struct cqc recv_buff_cqc;

    struct pollfd fds[GENPACKET_NRO_PIPES];
};

static struct genpacket_ctx ctx;

static bool test_p0_fixed(struct genpacket_ctx *ctx, int head) {
    int cnt = cqc_cnt(ctx->recv_buff_cqc);
    if (cnt < 31) return -1;

    int retval = 31;
    struct p0_fixed *packet = (struct p0_fixed *) &ctx->recv_buff[head];
    
    if (packet->frame0 != 0x10) return -1;
    if (packet->frame1 != 0x30) return -1;
    if (packet->frame2 != 0x20) return -1;


    return retval;
}
static bool test_p1_fixed(struct genpacket_ctx *ctx, int head) {
    int cnt = cqc_cnt(ctx->recv_buff_cqc);
    if (cnt < 12) return -1;
    return 12;
}
static bool test_p2_fixed(struct genpacket_ctx *ctx, int head) {
    int cnt = cqc_cnt(ctx->recv_buff_cqc);
    if (cnt < 46) return -1;

    int retval = 46;
    struct p2_fixed *packet = (struct p2_fixed *) &ctx->recv_buff[head];
    
    if (packet->frame0 != 0x10) return -1;


    return retval;
}
static int test_p3_calculated(struct genpacket_ctx *ctx, int head) {
    int cnt = cqc_cnt(ctx->recv_buff_cqc);
    if (cnt < 7) return -1;

    int retval = 7;
    struct p3_calculated *packet = (struct p3_calculated *) &ctx->recv_buff[head];
    return -1;

    return retval;
}

static bool check_fds_read(struct genpacket_ctx *ctx, int timeout) {
    int i = 0;

    struct pollfd fds[GENPACKET_NRO_PIPES];
    fds[i].fd = ctx->params.pipe_fds[i];
    fds[i].events = 0;

    if (ctx->params.pipe_dir[i] & GENPACKET_R > 0) fds[i].events |= POLLIN;
    if (ctx->params.pipe_dir[i] & GENPACKET_W > 0) fds[i].events |= POLLOUT;

    if (poll(fds, GENPACKET_NRO_PIPES, timeout) > 0) return true;
    return false;
}

int genpacket_init(struct genpacket_params *params) {
    memcpy(&ctx.params, params, sizeof(struct genpacket_params) );

    cqc_init(ctx.recv_buff_cqc,ARRAY_SZ(ctx.recv_buff));
    memset(&ctx.recv_buff, 0x0, cqc_qsz(ctx.recv_buff_cqc) );

    return (EXIT_SUCCESS);
}

int genpacket_process(int timeout) {
    if (check_fds_read(&ctx, timeout) ) {
        if (cqc_space(ctx.recv_buff_cqc) > 0) {
            int readsz = cqc_space_to_end(ctx.recv_buff_cqc);
            int head = ctx.recv_buff_cqc.head;
            int rdsz_r = read(ctx.params.pipe_fds[0], &ctx.recv_buff[head], readsz);
            ctx.recv_buff_cqc.head += rdsz_r;
        }

        /* 
           These test functions return '-1' when their packet is not (completely) found. 
           Else they will return the size of the packet.
        */
        
        while (cqc_space(ctx.recv_buff_cqc) < GENPACKET_READ_SZ) {
            int head = cqc_peek(ctx.recv_buff_cqc, 0);
            int size = -1;

            
            if ( (size == -1) && (size = (test_p0_fixed(&ctx, head) ) ) ) genpacket_p0_fixed_received( (struct p0_fixed *) &ctx.recv_buff[head], ctx.params.private_ctx);
            if ( (size == -1) && (size = (test_p1_fixed(&ctx, head) ) ) ) genpacket_p1_fixed_received( (struct p1_fixed *) &ctx.recv_buff[head], ctx.params.private_ctx);
            if ( (size == -1) && (size = (test_p2_fixed(&ctx, head) ) ) ) genpacket_p2_fixed_received( (struct p2_fixed *) &ctx.recv_buff[head], ctx.params.private_ctx);
            if ( (size == -1) && (size = (test_p3_calculated(&ctx, head) ) ) ) genpacket_p3_calculated_received( (struct p3_calculated *) &ctx.recv_buff[head], ctx.params.private_ctx);


            if (size == -1) ctx.recv_buff_cqc.tail--;
            else ctx.recv_buff_cqc.tail -= size;
        }
    }

    return (EXIT_SUCCESS);
}

