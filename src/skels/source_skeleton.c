/*
 * File automatically generated by
 * gengen 1.4 by Lorenzo Bettini 
 * http://www.gnu.org/software/gengen
 */

#include "source_skeleton.h"


static void
generate_string(const char *s, FILE *stream, unsigned int indent)
{
  const char *sub = s;
  char *indent_str;
  unsigned int i;

  if (!indent || strchr (s, '\n') == 0)
    {
      fprintf (stream, "%s", s);
      return;
    }

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';

  while ( (sub=strchr (s, '\n')) != 0 )
    {
      fwrite (s, sizeof(char), (sub-s)+1, stream);
      s = sub+1;
      if (s[0])
        fprintf (stream, "%s", indent_str);
    }
  if (s[0])
    fwrite (s, sizeof(char), strlen (s), stream);

  free (indent_str);
}

void
generate_source_skeleton(FILE *stream, struct source_skeleton_gen_struct *record, unsigned int indent)
{
  char *indent_str;
  unsigned int i;

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';
  indent = 0;

  fprintf (stream, "%s", "/*");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  File autogenerated by ");
  fprintf (stream, "%s", (record->genpacket ? record->genpacket : ""));
  fprintf (stream, "%s", " ");
  fprintf (stream, "%s", (record->version ? record->version : ""));
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  generated with the following command:");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 2;
  fprintf (stream, "%s", "  ");
  fprintf (stream, "%s", (record->genpacket ? record->genpacket : ""));
  fprintf (stream, "%s", " ");
  fprintf (stream, "%s", (record->cmd_options ? record->cmd_options : ""));
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  The developers of genpacket consider the fixed text that goes in all");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  genpacket output files to be in the public domain:");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  we make no copyright claims on it.");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "*/");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 1;
  fprintf (stream, "%s", " ");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "/* If we use autoconf.  */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifdef HAVE_CONFIG_H");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include \"config.h\"");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <stdio.h> ");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <stdlib.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <string.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <poll.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include \"");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", ".h\"");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifndef FIX_UNUSED");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params params;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 4;
  fprintf (stream, "%s", "    ");
  if (record->receive_buffers)
    generate_string (record->receive_buffers, stream, indent + strlen (indent_str));
  else
    generate_receive_buffers (stream, record, indent + strlen (indent_str));
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 4;
  fprintf (stream, "%s", "    ");
  if (record->send_buffers)
    generate_string (record->send_buffers, stream, indent + strlen (indent_str));
  else
    generate_send_buffers (stream, record, indent + strlen (indent_str));
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct pollfd fds[");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES];");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "};");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "static struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx ctx;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "static bool check_fds(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx *ctx) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    int i = 0;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#if ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES > 1");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    for (i = 0; i < ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES; i++) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        fds[i].fd = ctx->params.pipe_fds[i];");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        fds[i].events = 0;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        if (ctx->params.pipe_dir[i] & ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_R > 0) fds[i].events |= POLLIN;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        if (ctx->params.pipe_dir[i] & ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_W > 0) fds[i].events |= POLLOUT;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#if ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES > 1");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    if (poll(fds, ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES, 0) > 0) return true;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return false;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "int ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_init(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params *params) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    memcpy(&ctx.params, params, sizeof(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params) );");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "int ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_process() {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);

  free (indent_str);
}

void
generatep_source_skeleton(FILE *stream, unsigned int indent, const char *cmd_options, const char *genpacket, const char *ifndefname, const char *prefix, const char *receive_buffers, const char *send_buffers, const char *version)
{
  struct source_skeleton_gen_struct record;
  
  record.cmd_options = cmd_options;
  record.genpacket = genpacket;
  record.ifndefname = ifndefname;
  record.prefix = prefix;
  record.receive_buffers = receive_buffers;
  record.send_buffers = send_buffers;
  record.version = version;

  generate_source_skeleton (stream, &record, indent);
}

char *
genstring_source_skeleton(struct source_skeleton_gen_struct *record, unsigned int indent)
{
  char *indent_str, *output;
  unsigned int i;
  int len;

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';

  len = strcnt_source_skeleton (record, indent);
  output = (char *) malloc (len + 1);
  output[0] = '\0';

  strcat (output, "/*");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  File autogenerated by ");
  if (record->genpacket) strcat (output, record->genpacket);
  strcat (output, " ");
  if (record->version) strcat (output, record->version);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  generated with the following command:");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  ");
  if (record->genpacket) strcat (output, record->genpacket);
  strcat (output, " ");
  if (record->cmd_options) strcat (output, record->cmd_options);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  The developers of genpacket consider the fixed text that goes in all");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  genpacket output files to be in the public domain:");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  we make no copyright claims on it.");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "*/");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, " ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "/* If we use autoconf.  */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifdef HAVE_CONFIG_H");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include \"config.h\"");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <stdio.h> ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <stdlib.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <string.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <poll.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include \"");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, ".h\"");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifndef FIX_UNUSED");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params params;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    ");
  if (record->receive_buffers) strcat (output, record->receive_buffers);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    ");
  if (record->send_buffers) strcat (output, record->send_buffers);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct pollfd fds[");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "};");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "static struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx ctx;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "static bool check_fds(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx *ctx) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    int i = 0;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#if ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES > 1");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    for (i = 0; i < ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES; i++) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        fds[i].fd = ctx->params.pipe_fds[i];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        fds[i].events = 0;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        if (ctx->params.pipe_dir[i] & ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_R > 0) fds[i].events |= POLLIN;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        if (ctx->params.pipe_dir[i] & ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_W > 0) fds[i].events |= POLLOUT;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#if ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES > 1");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    if (poll(fds, ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES, 0) > 0) return true;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return false;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "int ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_init(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params *params) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    memcpy(&ctx.params, params, sizeof(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params) );");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "int ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_process() {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);

  free (indent_str);

  return output;
}

char *
genstringp_source_skeleton(unsigned int indent, const char *cmd_options, const char *genpacket, const char *ifndefname, const char *prefix, const char *receive_buffers, const char *send_buffers, const char *version)
{
  struct source_skeleton_gen_struct record;
  
  record.cmd_options = cmd_options;
  record.genpacket = genpacket;
  record.ifndefname = ifndefname;
  record.prefix = prefix;
  record.receive_buffers = receive_buffers;
  record.send_buffers = send_buffers;
  record.version = version;

  return genstring_source_skeleton (&record, indent);
}

int
strcnt_source_skeleton(struct source_skeleton_gen_struct *record, unsigned int indent)
{
  int length = 0;
  
  length += (record->genpacket ? strlen (record->genpacket) : 0) * 2;
  length += (record->version ? strlen (record->version) : 0) * 1;
  length += (record->cmd_options ? strlen (record->cmd_options) : 0) * 1;
  length += (record->prefix ? strlen (record->prefix) : 0) * 9;
  length += (record->receive_buffers ? strlen (record->receive_buffers) : 0) * 1;
  length += (record->send_buffers ? strlen (record->send_buffers) : 0) * 1;
  length += (record->ifndefname ? strlen (record->ifndefname) : 0) * 7;

  return length + 1313;
}

void
init_source_skeleton_gen_struct(struct source_skeleton_gen_struct *record)
{
  record->cmd_options = 0;
  record->genpacket = 0;
  record->ifndefname = 0;
  record->prefix = 0;
  record->receive_buffers = 0;
  record->send_buffers = 0;
  record->version = 0;
}

