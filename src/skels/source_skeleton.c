/*
 * File automatically generated by
 * gengen 1.4.3rc by Lorenzo Bettini 
 * http://www.gnu.org/software/gengen
 */

#include "source_skeleton.h"


static void
generate_string(const char *s, FILE *stream, unsigned int indent)
{
  const char *sub = s;
  char *indent_str;
  unsigned int i;

  if (!indent || strchr (s, '\n') == 0)
    {
      fprintf (stream, "%s", s);
      return;
    }

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';

  while ( (sub=strchr (s, '\n')) != 0 )
    {
      fwrite (s, sizeof(char), (sub-s)+1, stream);
      s = sub+1;
      if (s[0])
        fprintf (stream, "%s", indent_str);
    }
  if (s[0])
    fwrite (s, sizeof(char), strlen (s), stream);

  free (indent_str);
}


static char *
int_to_string(int i)
{
  static char buffer[256];

  snprintf (buffer, 255, "%d", i);

  return buffer;
}

void
generate_source_skeleton(FILE *stream, struct source_skeleton_gen_struct *record, unsigned int indent)
{
  char *indent_str;
  unsigned int i;

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';
  indent = 0;

  fprintf (stream, "%s", "/*");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  File autogenerated by ");
  fprintf (stream, "%s", (record->genpacket ? record->genpacket : ""));
  fprintf (stream, "%s", " ");
  fprintf (stream, "%s", (record->version ? record->version : ""));
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  generated with the following command:");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 2;
  fprintf (stream, "%s", "  ");
  fprintf (stream, "%s", (record->genpacket ? record->genpacket : ""));
  fprintf (stream, "%s", " ");
  fprintf (stream, "%s", (record->cmd_options ? record->cmd_options : ""));
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  The developers of genpacket consider the fixed text that goes in all");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  genpacket output files to be in the public domain:");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  we make no copyright claims on it.");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "*/");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 1;
  fprintf (stream, "%s", " ");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "/* If we use autoconf.  */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifdef HAVE_CONFIG_H");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include \"config.h\"");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <stdio.h> ");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <stdlib.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <stdbool.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <string.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <unistd.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <poll.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include \"");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", ".h\"");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifndef FIX_UNUSED");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define ARRAY_SZ(a) (sizeof(a) / sizeof(a[0]))");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_READ_SZ (");
  fprintf (stream, "%d", record->read_sz);
  fprintf (stream, "%s", ")");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params params;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* TODO: One receive queue per pipe */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    uint8_t recv_buff[");
  fprintf (stream, "%d", record->size);
  fprintf (stream, "%s", "];");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct cqc recv_buff_cqc;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct pollfd pfds[");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES * 2];");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "};");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "static struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  if (record->test_packets)
    generate_string (record->test_packets, stream, indent + strlen (indent_str));
  else
    generate_test_packets (stream, record, indent + strlen (indent_str));
  fprintf (stream, "%s", indent_str);
  if (record->send_functions_impl)
    generate_string (record->send_functions_impl, stream, indent + strlen (indent_str));
  else
    generate_send_functions_impl (stream, record, indent + strlen (indent_str));
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "static bool check_fds(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx *ctx, int timeout) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    if (poll(ctx->pfds, ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES *2, timeout) > 0) return true;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return false;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "static bool check_read_fds(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx *ctx, int pipe) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    for (int i = 0; i < (");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES *2); i++) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        /* TODO: check for specific pipe here! */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        if ( (ctx->pfds[i].revents & POLLIN) > 0) return true;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return false;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "static bool check_write_fds(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx *ctx, int pipe) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    for (int i = 0; i < (");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES *2); i++) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        /* TODO: check for specific pipe here! */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        if ( (ctx->pfds[i].revents & POLLOUT) > 0) return true;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return false;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "int ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_init(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params *params) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    memcpy(&");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.params, params, sizeof(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params) );");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    cqc_init(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc,ARRAY_SZ(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff));");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    memset(&");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff, 0x0, cqc_qsz(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc) );");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    int fd = 0;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    for (int i = 0; i < ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES; i++) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 8;
  fprintf (stream, "%s", "        ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.pfds[fd].fd = ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.params.rfds[i];");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 8;
  fprintf (stream, "%s", "        ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.pfds[fd].events = POLLIN;");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        if (");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.params.rfds[i] == ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.params.wfds[i]) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 12;
  fprintf (stream, "%s", "            ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.pfds[fd].events |= POLLOUT;");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        else {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            fd++;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 12;
  fprintf (stream, "%s", "            ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.pfds[fd].fd = ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.params.wfds[i];");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 12;
  fprintf (stream, "%s", "            ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.pfds[fd].events = POLLOUT;");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return (EXIT_SUCCESS);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "int ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_process(int timeout) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    if (check_fds(&");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx, timeout) ) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        /* TODO: check_read per pipe */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        if (check_read_fds(&");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx, 0) ) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            if (cqc_space(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc) > 0) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                int readsz = cqc_space_to_end(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                int head = ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc.head;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                int rdsz_r = read(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.params.rfds[0], &");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff[head], readsz);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 16;
  fprintf (stream, "%s", "                ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc.head += rdsz_r;");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            /* ");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "               These test functions return '-1' when their packet is not (completely) found. ");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "               Else they will return the size of the packet.");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 12;
  fprintf (stream, "%s", "            ");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            while (cqc_space(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc) < ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_READ_SZ) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                int head = cqc_peek(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc, 0);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                int size = -1;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 16;
  fprintf (stream, "%s", "                ");
  if (record->call_recv_tests)
    generate_string (record->call_recv_tests, stream, indent + strlen (indent_str));
  else
    generate_call_recv_tests (stream, record, indent + strlen (indent_str));
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                if (size == -1) ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc.tail--;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                else ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx.recv_buff_cqc.tail -= size;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return (EXIT_SUCCESS);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);

  free (indent_str);
}

void
generatep_source_skeleton(FILE *stream, unsigned int indent, const char *call_recv_tests, const char *cmd_options, const char *genpacket, const char *ifndefname, const char *prefix, int read_sz, const char *send_functions_impl, int size, const char *test_packets, const char *version)
{
  struct source_skeleton_gen_struct record;
  
  record.call_recv_tests = call_recv_tests;
  record.cmd_options = cmd_options;
  record.genpacket = genpacket;
  record.ifndefname = ifndefname;
  record.prefix = prefix;
  record.read_sz = read_sz;
  record.send_functions_impl = send_functions_impl;
  record.size = size;
  record.test_packets = test_packets;
  record.version = version;

  generate_source_skeleton (stream, &record, indent);
}

char *
genstring_source_skeleton(struct source_skeleton_gen_struct *record, unsigned int indent)
{
  char *indent_str, *output;
  unsigned int i;
  int len;

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';

  len = strcnt_source_skeleton (record, indent);
  output = (char *) malloc (len + 1);
  output[0] = '\0';

  strcat (output, "/*");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  File autogenerated by ");
  if (record->genpacket) strcat (output, record->genpacket);
  strcat (output, " ");
  if (record->version) strcat (output, record->version);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  generated with the following command:");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  ");
  if (record->genpacket) strcat (output, record->genpacket);
  strcat (output, " ");
  if (record->cmd_options) strcat (output, record->cmd_options);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  The developers of genpacket consider the fixed text that goes in all");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  genpacket output files to be in the public domain:");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  we make no copyright claims on it.");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "*/");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, " ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "/* If we use autoconf.  */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifdef HAVE_CONFIG_H");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include \"config.h\"");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <stdio.h> ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <stdlib.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <stdbool.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <string.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <unistd.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <poll.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include \"");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, ".h\"");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifndef FIX_UNUSED");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define ARRAY_SZ(a) (sizeof(a) / sizeof(a[0]))");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_READ_SZ (");
  strcat (output, int_to_string (record->read_sz));
  strcat (output, ")");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params params;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* TODO: One receive queue per pipe */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    uint8_t recv_buff[");
  strcat (output, int_to_string (record->size));
  strcat (output, "];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct cqc recv_buff_cqc;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct pollfd pfds[");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES * 2];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "};");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "static struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  if (record->test_packets) strcat (output, record->test_packets);
  strcat (output, indent_str);
  if (record->send_functions_impl) strcat (output, record->send_functions_impl);
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "static bool check_fds(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx *ctx, int timeout) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    if (poll(ctx->pfds, ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES *2, timeout) > 0) return true;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return false;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "static bool check_read_fds(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx *ctx, int pipe) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    for (int i = 0; i < (");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES *2); i++) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        /* TODO: check for specific pipe here! */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        if ( (ctx->pfds[i].revents & POLLIN) > 0) return true;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return false;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "static bool check_write_fds(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx *ctx, int pipe) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    for (int i = 0; i < (");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES *2); i++) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        /* TODO: check for specific pipe here! */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        if ( (ctx->pfds[i].revents & POLLOUT) > 0) return true;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return false;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "int ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_init(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params *params) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    memcpy(&");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.params, params, sizeof(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params) );");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    cqc_init(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc,ARRAY_SZ(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff));");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    memset(&");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff, 0x0, cqc_qsz(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc) );");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    int fd = 0;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    for (int i = 0; i < ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES; i++) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.pfds[fd].fd = ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.params.rfds[i];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.pfds[fd].events = POLLIN;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        if (");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.params.rfds[i] == ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.params.wfds[i]) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.pfds[fd].events |= POLLOUT;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        else {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            fd++;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.pfds[fd].fd = ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.params.wfds[i];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.pfds[fd].events = POLLOUT;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return (EXIT_SUCCESS);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "int ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_process(int timeout) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    if (check_fds(&");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx, timeout) ) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        /* TODO: check_read per pipe */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        if (check_read_fds(&");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx, 0) ) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            if (cqc_space(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc) > 0) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                int readsz = cqc_space_to_end(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                int head = ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc.head;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                int rdsz_r = read(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.params.rfds[0], &");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff[head], readsz);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc.head += rdsz_r;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            /* ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "               These test functions return '-1' when their packet is not (completely) found. ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "               Else they will return the size of the packet.");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            while (cqc_space(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc) < ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_READ_SZ) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                int head = cqc_peek(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc, 0);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                int size = -1;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                ");
  if (record->call_recv_tests) strcat (output, record->call_recv_tests);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                if (size == -1) ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc.tail--;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                else ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx.recv_buff_cqc.tail -= size;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return (EXIT_SUCCESS);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);

  free (indent_str);

  return output;
}

char *
genstringp_source_skeleton(unsigned int indent, const char *call_recv_tests, const char *cmd_options, const char *genpacket, const char *ifndefname, const char *prefix, int read_sz, const char *send_functions_impl, int size, const char *test_packets, const char *version)
{
  struct source_skeleton_gen_struct record;
  
  record.call_recv_tests = call_recv_tests;
  record.cmd_options = cmd_options;
  record.genpacket = genpacket;
  record.ifndefname = ifndefname;
  record.prefix = prefix;
  record.read_sz = read_sz;
  record.send_functions_impl = send_functions_impl;
  record.size = size;
  record.test_packets = test_packets;
  record.version = version;

  return genstring_source_skeleton (&record, indent);
}

int
strcnt_source_skeleton(struct source_skeleton_gen_struct *record, unsigned int indent)
{
  int length = 0;
  
  length += (record->genpacket ? strlen (record->genpacket) : 0) * 2;
  length += (record->version ? strlen (record->version) : 0) * 1;
  length += (record->cmd_options ? strlen (record->cmd_options) : 0) * 1;
  length += (record->prefix ? strlen (record->prefix) : 0) * 38;
  length += (record->ifndefname ? strlen (record->ifndefname) : 0) * 7;
  length += strlen (int_to_string (record->read_sz)) * 1;
  length += strlen (int_to_string (record->size)) * 1;
  length += (record->test_packets ? strlen (record->test_packets) : 0) * 1;
  length += (record->send_functions_impl ? strlen (record->send_functions_impl) : 0) * 1;
  length += (record->call_recv_tests ? strlen (record->call_recv_tests) : 0) * 1;

  return length + 3391;
}

void
init_source_skeleton_gen_struct(struct source_skeleton_gen_struct *record)
{
  record->call_recv_tests = 0;
  record->cmd_options = 0;
  record->genpacket = 0;
  record->ifndefname = 0;
  record->prefix = 0;
  record->read_sz = 0;
  record->send_functions_impl = 0;
  record->size = 0;
  record->test_packets = 0;
  record->version = 0;
}

