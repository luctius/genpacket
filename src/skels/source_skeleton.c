/*
 * File automatically generated by
 * gengen 1.4.3rc by Lorenzo Bettini 
 * http://www.gnu.org/software/gengen
 */

#include "source_skeleton.h"


static void
generate_string(const char *s, FILE *stream, unsigned int indent)
{
  const char *sub = s;
  char *indent_str;
  unsigned int i;

  if (!indent || strchr (s, '\n') == 0)
    {
      fprintf (stream, "%s", s);
      return;
    }

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';

  while ( (sub=strchr (s, '\n')) != 0 )
    {
      fwrite (s, sizeof(char), (sub-s)+1, stream);
      s = sub+1;
      if (s[0])
        fprintf (stream, "%s", indent_str);
    }
  if (s[0])
    fwrite (s, sizeof(char), strlen (s), stream);

  free (indent_str);
}


static char *
int_to_string(int i)
{
  static char buffer[256];

  snprintf (buffer, 255, "%d", i);

  return buffer;
}

void
generate_source_skeleton(FILE *stream, struct source_skeleton_gen_struct *record, unsigned int indent)
{
  char *indent_str;
  unsigned int i;

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';
  indent = 0;

  fprintf (stream, "%s", "/*");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  File autogenerated by ");
  fprintf (stream, "%s", (record->genpacket ? record->genpacket : ""));
  fprintf (stream, "%s", " ");
  fprintf (stream, "%s", (record->version ? record->version : ""));
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  generated with the following command:");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 2;
  fprintf (stream, "%s", "  ");
  fprintf (stream, "%s", (record->genpacket ? record->genpacket : ""));
  fprintf (stream, "%s", " ");
  fprintf (stream, "%s", (record->cmd_options ? record->cmd_options : ""));
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  The developers of genpacket consider the fixed text that goes in all");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  genpacket output files to be in the public domain:");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "  we make no copyright claims on it.");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "*/");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 1;
  fprintf (stream, "%s", " ");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "/* If we use autoconf.  */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifdef HAVE_CONFIG_H");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include \"config.h\"");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <stdio.h> ");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <stdlib.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <stdbool.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <string.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include <poll.h>");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#include \"");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", ".h\"");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifndef FIX_UNUSED");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define ARRAY_SZ(a) (sizeof(a) / sizeof(a[0]))");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_READ_SZ (");
  fprintf (stream, "%d", record->read_sz);
  fprintf (stream, "%s", ")");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params params;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    uint8_t recv_buff[");
  fprintf (stream, "%d", record->size);
  fprintf (stream, "%s", "];");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct cqc recv_buff_cqc;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct pollfd fds[");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES];");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "};");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "static struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx ctx;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  if (record->test_packets)
    generate_string (record->test_packets, stream, indent + strlen (indent_str));
  else
    generate_test_packets (stream, record, indent + strlen (indent_str));
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "static bool check_fds_read(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_ctx *ctx, int timeout) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    int i = 0;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    struct pollfd fds[");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES];");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    fds[i].fd = ctx->params.pipe_fds[i];");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    fds[i].events = 0;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    if (ctx->params.pipe_dir[i] & ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_R > 0) fds[i].events |= POLLIN;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    if (ctx->params.pipe_dir[i] & ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_W > 0) fds[i].events |= POLLOUT;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    if (poll(fds, ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_NRO_PIPES, timeout) > 0) return true;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return false;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "int ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_init(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params *params) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    memcpy(&ctx.params, params, sizeof(struct ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_params) );");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    cqc_init(ctx.recv_buff_cqc,ARRAY_SZ(ctx.recv_buff));");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    memset(&ctx.recv_buff, 0x0, cqc_qsz(ctx.recv_buff_cqc) );");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return (EXIT_SUCCESS);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "int ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_process(int timeout) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    if (check_fds_read(&ctx, timeout) ) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        if (cqc_space(ctx.recv_buff_cqc) > 0) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            int readsz = cqc_space_to_end(ctx.recv_buff_cqc);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            int head = ctx.recv_buff_cqc.head;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            int rdsz_r = read(ctx.params.pipe_fds[0], &ctx.recv_buff[head], readsz);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            ctx.recv_buff_cqc.head += rdsz_r;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        /* ");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "           These test functions return '-1' when their packet is not (completely) found. ");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "           Else they will return the size of the packet.");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 8;
  fprintf (stream, "%s", "        ");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        while (cqc_space(ctx.recv_buff_cqc) < ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_READ_SZ) {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            int head = cqc_peek(ctx.recv_buff_cqc, 0);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            int size = -1;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 12;
  fprintf (stream, "%s", "            ");
  if (record->call_recv_tests)
    generate_string (record->call_recv_tests, stream, indent + strlen (indent_str));
  else
    generate_call_recv_tests (stream, record, indent + strlen (indent_str));
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            if (size == -1) ctx.recv_buff_cqc.tail--;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "            else ctx.recv_buff_cqc.tail -= size;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "        }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    }");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    return (EXIT_SUCCESS);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);

  free (indent_str);
}

void
generatep_source_skeleton(FILE *stream, unsigned int indent, const char *call_recv_tests, const char *cmd_options, const char *genpacket, const char *ifndefname, const char *prefix, int read_sz, int size, const char *test_packets, const char *version)
{
  struct source_skeleton_gen_struct record;
  
  record.call_recv_tests = call_recv_tests;
  record.cmd_options = cmd_options;
  record.genpacket = genpacket;
  record.ifndefname = ifndefname;
  record.prefix = prefix;
  record.read_sz = read_sz;
  record.size = size;
  record.test_packets = test_packets;
  record.version = version;

  generate_source_skeleton (stream, &record, indent);
}

char *
genstring_source_skeleton(struct source_skeleton_gen_struct *record, unsigned int indent)
{
  char *indent_str, *output;
  unsigned int i;
  int len;

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';

  len = strcnt_source_skeleton (record, indent);
  output = (char *) malloc (len + 1);
  output[0] = '\0';

  strcat (output, "/*");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  File autogenerated by ");
  if (record->genpacket) strcat (output, record->genpacket);
  strcat (output, " ");
  if (record->version) strcat (output, record->version);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  generated with the following command:");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  ");
  if (record->genpacket) strcat (output, record->genpacket);
  strcat (output, " ");
  if (record->cmd_options) strcat (output, record->cmd_options);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  The developers of genpacket consider the fixed text that goes in all");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  genpacket output files to be in the public domain:");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "  we make no copyright claims on it.");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "*/");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, " ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "/* If we use autoconf.  */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifdef HAVE_CONFIG_H");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include \"config.h\"");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <stdio.h> ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <stdlib.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <stdbool.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <string.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include <poll.h>");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#include \"");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, ".h\"");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifndef FIX_UNUSED");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define ARRAY_SZ(a) (sizeof(a) / sizeof(a[0]))");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_READ_SZ (");
  strcat (output, int_to_string (record->read_sz));
  strcat (output, ")");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params params;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    uint8_t recv_buff[");
  strcat (output, int_to_string (record->size));
  strcat (output, "];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct cqc recv_buff_cqc;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct pollfd fds[");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "};");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "static struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx ctx;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  if (record->test_packets) strcat (output, record->test_packets);
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "static bool check_fds_read(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_ctx *ctx, int timeout) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    int i = 0;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    struct pollfd fds[");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    fds[i].fd = ctx->params.pipe_fds[i];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    fds[i].events = 0;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    if (ctx->params.pipe_dir[i] & ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_R > 0) fds[i].events |= POLLIN;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    if (ctx->params.pipe_dir[i] & ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_W > 0) fds[i].events |= POLLOUT;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    if (poll(fds, ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_NRO_PIPES, timeout) > 0) return true;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return false;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "int ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_init(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params *params) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    memcpy(&ctx.params, params, sizeof(struct ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_params) );");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    cqc_init(ctx.recv_buff_cqc,ARRAY_SZ(ctx.recv_buff));");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    memset(&ctx.recv_buff, 0x0, cqc_qsz(ctx.recv_buff_cqc) );");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return (EXIT_SUCCESS);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "int ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_process(int timeout) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    if (check_fds_read(&ctx, timeout) ) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        if (cqc_space(ctx.recv_buff_cqc) > 0) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            int readsz = cqc_space_to_end(ctx.recv_buff_cqc);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            int head = ctx.recv_buff_cqc.head;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            int rdsz_r = read(ctx.params.pipe_fds[0], &ctx.recv_buff[head], readsz);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            ctx.recv_buff_cqc.head += rdsz_r;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        /* ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "           These test functions return '-1' when their packet is not (completely) found. ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "           Else they will return the size of the packet.");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        ");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        while (cqc_space(ctx.recv_buff_cqc) < ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_READ_SZ) {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            int head = cqc_peek(ctx.recv_buff_cqc, 0);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            int size = -1;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            ");
  if (record->call_recv_tests) strcat (output, record->call_recv_tests);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            if (size == -1) ctx.recv_buff_cqc.tail--;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "            else ctx.recv_buff_cqc.tail -= size;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "        }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    }");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    return (EXIT_SUCCESS);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);

  free (indent_str);

  return output;
}

char *
genstringp_source_skeleton(unsigned int indent, const char *call_recv_tests, const char *cmd_options, const char *genpacket, const char *ifndefname, const char *prefix, int read_sz, int size, const char *test_packets, const char *version)
{
  struct source_skeleton_gen_struct record;
  
  record.call_recv_tests = call_recv_tests;
  record.cmd_options = cmd_options;
  record.genpacket = genpacket;
  record.ifndefname = ifndefname;
  record.prefix = prefix;
  record.read_sz = read_sz;
  record.size = size;
  record.test_packets = test_packets;
  record.version = version;

  return genstring_source_skeleton (&record, indent);
}

int
strcnt_source_skeleton(struct source_skeleton_gen_struct *record, unsigned int indent)
{
  int length = 0;
  
  length += (record->genpacket ? strlen (record->genpacket) : 0) * 2;
  length += (record->version ? strlen (record->version) : 0) * 1;
  length += (record->cmd_options ? strlen (record->cmd_options) : 0) * 1;
  length += (record->prefix ? strlen (record->prefix) : 0) * 9;
  length += (record->ifndefname ? strlen (record->ifndefname) : 0) * 7;
  length += strlen (int_to_string (record->read_sz)) * 1;
  length += strlen (int_to_string (record->size)) * 1;
  length += (record->test_packets ? strlen (record->test_packets) : 0) * 1;
  length += (record->call_recv_tests ? strlen (record->call_recv_tests) : 0) * 1;

  return length + 2434;
}

void
init_source_skeleton_gen_struct(struct source_skeleton_gen_struct *record)
{
  record->call_recv_tests = 0;
  record->cmd_options = 0;
  record->genpacket = 0;
  record->ifndefname = 0;
  record->prefix = 0;
  record->read_sz = 0;
  record->size = 0;
  record->test_packets = 0;
  record->version = 0;
}

