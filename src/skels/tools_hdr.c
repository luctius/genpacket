/*
 * File automatically generated by
 * gengen  by Lorenzo Bettini 
 * http://www.gnu.org/software/gengen
 */

#include "tools_hdr.h"

void
generate_tools_hdr(FILE *stream, struct tools_hdr_gen_struct *record, unsigned int indent)
{
  char *indent_str;
  unsigned int i;

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';
  indent = 0;

  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifndef ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_CQC_H");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_CQC_H");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifdef __cplusplus");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "extern \"C\" {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif /* __cplusplus */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define static_assert(pred, msg) _Static_assert( (pred), msg);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "struct cqc {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    int head;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    int tail;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    int size;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "};");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  if (record->modulo)
    {
      fprintf (stream, "%s", "//#define CQC_USE_MODULO /* Define this if you need arbitrary size queues instead of power of two sizes. */");
    }
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifdef CQC_USE_MODULO");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Init Circular buffer. In the case of Module, given size is the size of the buffer. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_init(cqc, sz) do { (cqc).size = sz; (cqc).tail = 0; (cqc).head = 0; } while (0)");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Size given with init. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_qsz(cqc)        ( (cqc).size )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Number of Items in the buffer. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_cnt(cqc)        ( ((cqc).head-(cqc).tail) % ((cqc).size) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Add new item, returns a free index and updates bookkeeping. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_put(cqc)        ( ((cqc).head++)          % ((cqc).size) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Retreive item, returns an used index and updates bookkeeping. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_get(cqc)        ( ((cqc).tail++)          % ((cqc).size) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Retreive item idx, does not touch bookkeeping. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_peek(cqc, idx)  ( ((cqc).tail+idx)        % ((cqc).size) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Space left in the buffer. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_space(cqc)      ( ((cqc).size)            - (cqc_cnt(cqc)) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_cnt_to_end(cqc)     ({int end = (cqc.size) - (cqc.tail); int n = ((cqc.head) + end) & ((cqc.size)-1); n < end ? n : end;})");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_space_to_end(cqc)   ({int end = (cqc.size) - 1 - (cqc.head); int n = (end + (cqc.tail)) & ((cqc.size)-1); n <= end ? n : end+1;})");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#elif !defined(CQC_USE_MODULO)");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Init Circular buffer. In the case of AND, given size is the nearest power of 2 of the given size. cqc_qsz should be used to initialise the buffer. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_init(cqc, sz) do { static_assert(sz != 0, \"cqc sz is zero\"); static_assert( (sz & (sz-1) ) == 0, \"cqc sz is not a power of 2.\"); (cqc).size = sz-1; (cqc).tail = 0; (cqc).head = 0; } while (0)");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Size calculated in init. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_qsz(cqc)        ( (cqc).size+1 )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Number of Items in the buffer. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_cnt(cqc)        ( ((cqc).head-(cqc).tail) & ((cqc).size) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Retreive item, returns an used index and updates bookkeeping. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_put(cqc)        ( ((cqc).head++)          & ((cqc).size) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Retreive item, returns an used index and updates bookkeeping. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_get(cqc)        ( ((cqc).tail++)          & ((cqc).size) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Retreive item idx, does not touch bookkeeping. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_peek(cqc, idx)  ( ((cqc).tail+idx)        & ((cqc).size) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* Space left in the buffer. */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_space(cqc)      ( ((cqc).size)            - (cqc_cnt(cqc)) )");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_cnt_to_end(cqc)     ({int end = (cqc.size) - (cqc.tail); int n = ((cqc.head) + end) & ((cqc.size)-1); n < end ? n : end;})");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#define cqc_space_to_end(cqc)   ({int end = (cqc.size) - 1 - (cqc.head); int n = (end + (cqc.tail)) & ((cqc.size)-1); n <= end ? n : end+1;})");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif /* CQC_USE_MODULO */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "typedef unsigned long long int ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_t;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "typedef struct {");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    bool table_generated;   /*!< Set to false, please */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    unsigned int width;     /*!< The width of the polynomial */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 4;
  fprintf (stream, "%s", "    ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_t poly;             /*!< The CRC polynomial */");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    bool reflect_in;         /*!< Whether the input shall be reflected or not */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 4;
  fprintf (stream, "%s", "    ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_t xor_in;           /*!< The initial value of the algorithm */");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    bool reflect_out;        /*!< Wether the output shall be reflected or not */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 4;
  fprintf (stream, "%s", "    ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_t xor_out;          /*!< The value which shall be XOR-ed to the final CRC value */");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    /* internal parameters */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 4;
  fprintf (stream, "%s", "    ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_t msb_mask;             /*!< a bitmask with the Most Significant Bit set to 1");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                                     initialise as (crc_t)1u << (width - 1) */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 4;
  fprintf (stream, "%s", "    ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_t crc_mask;             /*!< a bitmask with all width bits set to 1");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                                     initialise as (cfg->msb_mask - 1) | cfg->msb_mask */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "    unsigned int crc_shift;     /*!< a shift count that is used when width < 8");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "                                     initialise as cfg->width < 8 ? 8 - cfg->width : 0 */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  indent = 4;
  fprintf (stream, "%s", "    ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_t crc_table[256];");
  indent = 0;
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "} ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_cfg_t;");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "uint64_t ");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc(");
  fprintf (stream, "%s", (record->prefix ? record->prefix : ""));
  fprintf (stream, "%s", "_crc_cfg_t *cfg,const void *data, size_t len);");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#ifdef __cplusplus");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "}");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif /* __cplusplus */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "#endif /* ");
  fprintf (stream, "%s", (record->ifndefname ? record->ifndefname : ""));
  fprintf (stream, "%s", "_CQC_H */");
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);
  fprintf (stream, "%s", "\n");
  fprintf (stream, "%s", indent_str);

  free (indent_str);
}

void
generatep_tools_hdr(FILE *stream, unsigned int indent, const char *ifndefname, short modulo, const char *prefix)
{
  struct tools_hdr_gen_struct record;
  
  record.ifndefname = ifndefname;
  record.modulo = modulo;
  record.prefix = prefix;

  generate_tools_hdr (stream, &record, indent);
}

char *
genstring_tools_hdr(struct tools_hdr_gen_struct *record, unsigned int indent)
{
  char *indent_str, *output;
  unsigned int i;
  int len;

  indent_str = (char *) malloc (indent + 1);
  for (i = 0; i < indent; ++i)
    indent_str[i] = ' ';
  indent_str[indent] = '\0';

  len = strcnt_tools_hdr (record, indent);
  output = (char *) malloc (len + 1);
  output[0] = '\0';

  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifndef ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_CQC_H");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_CQC_H");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifdef __cplusplus");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "extern \"C\" {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif /* __cplusplus */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define static_assert(pred, msg) _Static_assert( (pred), msg);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "struct cqc {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    int head;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    int tail;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    int size;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "};");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  if (record->modulo)
    {
      strcat (output, "//#define CQC_USE_MODULO /* Define this if you need arbitrary size queues instead of power of two sizes. */");
    }
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifdef CQC_USE_MODULO");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Init Circular buffer. In the case of Module, given size is the size of the buffer. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_init(cqc, sz) do { (cqc).size = sz; (cqc).tail = 0; (cqc).head = 0; } while (0)");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Size given with init. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_qsz(cqc)        ( (cqc).size )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Number of Items in the buffer. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_cnt(cqc)        ( ((cqc).head-(cqc).tail) % ((cqc).size) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Add new item, returns a free index and updates bookkeeping. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_put(cqc)        ( ((cqc).head++)          % ((cqc).size) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Retreive item, returns an used index and updates bookkeeping. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_get(cqc)        ( ((cqc).tail++)          % ((cqc).size) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Retreive item idx, does not touch bookkeeping. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_peek(cqc, idx)  ( ((cqc).tail+idx)        % ((cqc).size) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Space left in the buffer. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_space(cqc)      ( ((cqc).size)            - (cqc_cnt(cqc)) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_cnt_to_end(cqc)     ({int end = (cqc.size) - (cqc.tail); int n = ((cqc.head) + end) & ((cqc.size)-1); n < end ? n : end;})");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_space_to_end(cqc)   ({int end = (cqc.size) - 1 - (cqc.head); int n = (end + (cqc.tail)) & ((cqc.size)-1); n <= end ? n : end+1;})");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#elif !defined(CQC_USE_MODULO)");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Init Circular buffer. In the case of AND, given size is the nearest power of 2 of the given size. cqc_qsz should be used to initialise the buffer. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_init(cqc, sz) do { static_assert(sz != 0, \"cqc sz is zero\"); static_assert( (sz & (sz-1) ) == 0, \"cqc sz is not a power of 2.\"); (cqc).size = sz-1; (cqc).tail = 0; (cqc).head = 0; } while (0)");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Size calculated in init. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_qsz(cqc)        ( (cqc).size+1 )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Number of Items in the buffer. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_cnt(cqc)        ( ((cqc).head-(cqc).tail) & ((cqc).size) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Retreive item, returns an used index and updates bookkeeping. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_put(cqc)        ( ((cqc).head++)          & ((cqc).size) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Retreive item, returns an used index and updates bookkeeping. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_get(cqc)        ( ((cqc).tail++)          & ((cqc).size) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Retreive item idx, does not touch bookkeeping. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_peek(cqc, idx)  ( ((cqc).tail+idx)        & ((cqc).size) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* Space left in the buffer. */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_space(cqc)      ( ((cqc).size)            - (cqc_cnt(cqc)) )");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_cnt_to_end(cqc)     ({int end = (cqc.size) - (cqc.tail); int n = ((cqc.head) + end) & ((cqc.size)-1); n < end ? n : end;})");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#define cqc_space_to_end(cqc)   ({int end = (cqc.size) - 1 - (cqc.head); int n = (end + (cqc.tail)) & ((cqc.size)-1); n <= end ? n : end+1;})");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif /* CQC_USE_MODULO */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "typedef unsigned long long int ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_t;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "typedef struct {");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    bool table_generated;   /*!< Set to false, please */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    unsigned int width;     /*!< The width of the polynomial */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_t poly;             /*!< The CRC polynomial */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    bool reflect_in;         /*!< Whether the input shall be reflected or not */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_t xor_in;           /*!< The initial value of the algorithm */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    bool reflect_out;        /*!< Wether the output shall be reflected or not */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_t xor_out;          /*!< The value which shall be XOR-ed to the final CRC value */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    /* internal parameters */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_t msb_mask;             /*!< a bitmask with the Most Significant Bit set to 1");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                                     initialise as (crc_t)1u << (width - 1) */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_t crc_mask;             /*!< a bitmask with all width bits set to 1");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                                     initialise as (cfg->msb_mask - 1) | cfg->msb_mask */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    unsigned int crc_shift;     /*!< a shift count that is used when width < 8");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "                                     initialise as cfg->width < 8 ? 8 - cfg->width : 0 */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "    ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_t crc_table[256];");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "} ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_cfg_t;");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "uint64_t ");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc(");
  if (record->prefix) strcat (output, record->prefix);
  strcat (output, "_crc_cfg_t *cfg,const void *data, size_t len);");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#ifdef __cplusplus");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "}");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif /* __cplusplus */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "#endif /* ");
  if (record->ifndefname) strcat (output, record->ifndefname);
  strcat (output, "_CQC_H */");
  strcat (output, "\n");
  strcat (output, indent_str);
  strcat (output, "\n");
  strcat (output, indent_str);

  free (indent_str);

  return output;
}

char *
genstringp_tools_hdr(unsigned int indent, const char *ifndefname, short modulo, const char *prefix)
{
  struct tools_hdr_gen_struct record;
  
  record.ifndefname = ifndefname;
  record.modulo = modulo;
  record.prefix = prefix;

  return genstring_tools_hdr (&record, indent);
}

int
strcnt_tools_hdr(struct tools_hdr_gen_struct *record, unsigned int indent)
{
  int length = 0;
  
  length += (record->ifndefname ? strlen (record->ifndefname) : 0) * 3;
if (record->modulo)
    {
      

    }
  length += (record->prefix ? strlen (record->prefix) : 0) * 10;

  return length + 4373;
}

void
init_tools_hdr_gen_struct(struct tools_hdr_gen_struct *record)
{
  record->ifndefname = 0;
  record->modulo = 0;
  record->prefix = 0;
}

